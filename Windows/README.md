
#### Nume: Chiricu Miruna
#### Grupa: 332CB

# Tema 2 #

### Synopsis:
- This is a minimal implementation of the stdio.h library for Linux file
  manipulation based on a personalised file structure: SO_FILE

```
struct _so_file {  
   HANDLE handle;  
   char mode[3];  
   long cursor;  
   char buffer[4096];  
   int buf_cursor;  
   int buf_len;  
   char prev_op; /* r or w or 0 */  
   int error_flag;  
   HANDLE processHandle;  
  
};
```

- **handle** = handle for the open file
- **mode** = 'r', 'w', 'a', 'r+', 'w+', 'a+'
- **cursor** = bytes from the beginning of the file
- **buffer**: when reading from/writing to file, fill this buffer to minimize
  system calls.
- **buf_cursor** = bytes from the beginning of the buffer
- **buf_len** = string length (how many bytes have been read and put into the buffer
  or how many bytes will be flushed to the file when need be)
- **prev_op** = previous operation: needs to keep count of the last operation so
  that buffering is done right
- **error_flag** = will be -1 if EOF is reached
- **processHandle** = in case of redirecting STDIN/STDOUT, this will be the pid of the process
  that executes a command and through which read/write operations will be
  performed

### Ideas behind the functions:
* **read:** max 4096 bytes, put them into the buffer. Next read operations
  will read from the buffer, not from the file, until:
    * all the buffer has been read
    * a write operation has invalidated the buffer (in this case there will be a
      read syscall and a reinitialization of the buffer)
    * the length of the string from the buffer is less than the buffer's size
      (which means EOF has been reached before reading 4096 bytes)
* **write**: max 4096 bytes will be put into the buffer before flushing them
  to a file. Next write operations will write to the buffer, until:
    -  the buffer has been filled and it has to be flushed to the file
    * a read operation has to overwrite the buffer so the current state
      of the buffer has to be flushed to the file

  *More about each function can be found in the comments.*

### Is this implementation efficient?
Considering it minimizes syscalls through buffering, yes, I'd say so. Could it
be better? It could always be better.

### Is it useful?
For educational purposes, yes. The best way to learn how system calls
affect program performance, how file manipulation is done behind the
usual API and how processes and pipes work is to actually implement
them yourself.

##### Note: The whole assignment has been implemented.

### How to compile & run?
This is a shared library, you can include it in another program:

```
make
>link /nologo /out:your_program.exe your_program.obj so_stdio.lib
```

### Bibliography
-   [Laborator 1](https://ocw.cs.pub.ro/courses/so/laboratoare/laborator-01 "so:laboratoare:laborator-01")
-   [Laborator 2](https://ocw.cs.pub.ro/courses/so/laboratoare/laborator-02 "so:laboratoare:laborator-02")
-   [Laborator 3](https://ocw.cs.pub.ro/courses/so/laboratoare/laborator-03 "so:laboratoare:laborator-03")

### Git (where you can see this beautiful .md README too)
https://gitlab.cs.pub.ro/miruna.chiricu/l3-so-assignments/tree/master/2-stdio





This archive contains a test suite for testing the Operating System stdio
library for Linux (`libso_stdio.so`). The test suite consists of several
unit tests, each of them testing a different functionality of the library.

# Archive Files
The checker consists of the following files:
* `README.md` - this file
* `NMakefile.checker` - Makefile for automating the build process on Windows
* `GNUmakefile` - Cygwin wrapper over NMakefile.checke
* `run_all.sh` - script to run all tests defined
* `_test` - directory that contains the following:
  * `run_test.sh` - runs only a specific test
  * `test_lib.sh` - a shell library used to run tests
  * `src/*.c` - source code for each test
  * `src/so_stdio.h` - so stdio header
  * `Makefile` - Makefile used for building the tests
  * `work/` - directory where tests output files are stored

# Checker
The local directory must contain the so_stdio library (`so_stdio.dll` and 
`so_stdio.lib`).
Use `make` to properly run the entire test suite:
```
make all
```

# Debug
If you want to keep the output files after running a test, you have to set
the `DO_CLEANUP` environment variable to `no`:
```
DO_CLEANUP=no make all
```

In order to run a single test, you can manually run the `run_test.sh` script:
```
_test/run_test.sh init
_test/run_test.sh <test>
_test/run_test.sh clean
```
where <test> is an integer specifying the test number
# Cleanup
To clean the files generated by the checker you have to run:
```
make clean
make bclean
```
